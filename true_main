import numpy as np
import cv2 as cv
import pydicom as dicom
import glob
from skimage.util import img_as_ubyte
import matplotlib.pyplot as plt
import os
import math
import matplotlib as mpl
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d import axes3d



def getLongContours(contours):
    longCont = []

    for cnt in contours:
        if (len(cnt) > 1000):
            longCont.append(cnt)

    return longCont

it = 0 # Variable global para el conteo de los bordes eliminados de todas las imagenes
def filterContoursLungs(contours, hierarchy):
    global it
    toDelete = []

    for i in range(0,len(hierarchy[0]),1): # Escogemos solo los bordes exteriores (sin contar el más exterior)
        if hierarchy[0,i,3] == -1:
            toDelete.append(i)
         #   print(it,"Eliminado por jerarquía")
            it = it + 1

    cont = np.delete(contours, toDelete, axis=0)
    toDelete = []

    i = 0

    for cnt in cont:
        if len(cnt) < 72:
            toDelete.append(i)
         #   print(it, "Eliminado por longitud")
            it = it + 1
        i = i + 1

    cont = np.delete(cont, toDelete, axis=0)

    return cont


def filterContoursArtery(contours, hierarchy):
    toDelete = []
    for i in range(0,len(hierarchy[0]),1): # Escogemos solo los bordes exteriores (sin contar el más exterior)
        if hierarchy[0,i,3] == -1:
            toDelete.append(i)
        #    print("Eliminado por jerarquía")
    cont = np.delete(contours, toDelete, axis=0)
    toDelete = []

    i=0

    for cnt in cont:
        if (len(cnt) > 65) or (len(cnt) < 20):
            toDelete.append(i)
           # print("Eliminado por longitud")
        else:
            circularity = (4 * math.pi * cv.contourArea(cnt))/(cv.arcLength(cnt, 1) * cv.arcLength(cnt, 1))
          #  print("Circularity =",circularity) # Suele tener como 0.85 de circularity, pero a veces se queda en unos 0.75. Al principio incluso es 0.69~
            if (circularity < 0.60):
                toDelete.append(i)
              #  print("Eliminado por circularidad")
        i = i + 1
    cont = np.delete(cont, toDelete, axis=0)
    return cont

def filterContoursBronq(contours, hierarchy):
    global it
    toDelete = []

    for i in range(0,len(hierarchy[0]),1): # Escogemos solo los bordes exteriores (sin contar el más exterior)
        if hierarchy[0,i,3] == -1:
            toDelete.append(i)
          #  print(it,"Eliminado por jerarquía")
            it = it + 1

    cont = np.delete(contours, toDelete, axis=0)
    #toDelete = []

    #i = 0

    #for cnt in cont:
    #    if len(cnt) < 50:
    #        toDelete.append(i)
    #        print(it, "Eliminado por longitud")
    #        it = it + 1
    #    i = i + 1

   # cont = np.delete(cont, toDelete, axis=0)

    return cont



def show_img(img, mode=0, erode=2, dilate=2):
    img = cv.normalize(img, None, 0, 255, norm_type=cv.NORM_MINMAX, dtype=cv.CV_8U)
    conts_lung = np.empty([1,2])
    if mode==0: # Modo de solo muestra
        cv.imshow("window",img)
    elif mode==1: # Modo de solo umbralizado
        ret, th2 = cv.threshold(img,80,255,cv.THRESH_BINARY)
        kernel = np.ones((5, 5), np.uint8)
        th2 = cv.erode(th2, kernel, iterations=erode)
        th2 = cv.dilate(th2, kernel, iterations=dilate)
        cv.imshow("window",th2)
    elif mode==2: # Modo de umbralizado + contornos
        ret, th2 = cv.threshold(img, 30, 255, cv.THRESH_BINARY)
        kernel = np.ones((5, 5), np.uint8)
        contours, hierarchy = cv.findContours(th2, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)

        conts_lung = filterContoursLungs(contours, hierarchy)

        cv_img = cv.cvtColor(img,cv.COLOR_GRAY2BGR) # th2 -> ver la umbralizada, img -> ver la original

        cv.drawContours(cv_img, conts_lung, -1, (0, 255, 0), 2)
        cv.imshow("window",cv_img)
    elif mode==3: # Modo de umbralizado + contornos + erosión y dilatación
        ret, th2 = cv.threshold(img, 30, 255, cv.THRESH_BINARY)
        kernel = np.ones((5, 5), np.uint8)
        th2 = cv.erode(th2, kernel, iterations=erode)
        th2 = cv.dilate(th2, kernel, iterations=dilate)
        contours, hierarchy = cv.findContours(th2, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)

        conts_lung = filterContoursLungs(contours, hierarchy)

        cv_img = cv.cvtColor(img, cv.COLOR_GRAY2BGR)  # th2 -> ver la umbralizada, img -> ver la original

        cv.drawContours(cv_img, conts_lung, -1, (0, 255, 0), 2)
        cv.imshow("window", cv_img)
    elif mode==4: # Modo de umbralizado + contornos + erosión y dilatación + detección de arteria aorta

        # Step 1. Arteria

        ret, th_art = cv.threshold(img, 5, 255, cv.THRESH_BINARY)
        kernel = np.ones((5, 5), np.uint8)
        th_art = cv.erode(th_art, kernel, iterations=erode)  # Erosion y dilatacion imagen arteria
        th_art = cv.dilate(th_art, kernel, iterations=dilate)
        img_arteria = th_art[190:400, 175:325]
        contours_art, hierarchy_art = cv.findContours(img_arteria, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
        conts_art = filterContoursArtery(contours_art, hierarchy_art)
        conts_art = [cnt + (175, 190) for cnt in conts_art]  # Para compensar el slice anterior
        # Aquí ya hemos obtenido el contorno de la arteria

        # Step 2. Pulmones

        ret, th_lung = cv.threshold(img, 30, 255, cv.THRESH_BINARY)
        cv.fillPoly(th_lung, pts = conts_art, color=(255,255,255)) # Coloreamos de blanco lo que antes era la arteria
        th_lung = cv.erode(th_lung, kernel, iterations=erode) # Erosion y dilatacion imagen pulmon
        th_lung = cv.dilate(th_lung, kernel, iterations=dilate)
        contours_lung, hierarchy_lung = cv.findContours(th_lung, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
        conts_lung = filterContoursLungs(contours_lung, hierarchy_lung)

        # Step 3. Dibujar los contornos


        cv_img = cv.cvtColor(img, cv.COLOR_GRAY2BGR)  # th2 -> ver la umbralizada, img -> ver la original

        cv.drawContours(cv_img, conts_art, -1, (0, 0, 255), 2)
        cv.drawContours(cv_img, conts_lung, -1, (0, 255, 0), 2)
        cv.imshow("window", cv_img)
    elif mode==5: # Modo de umbralizado + contornos + erosión y dilatación + detección de arteria aorta + detección de bronquios

        # Step 1. Arteria

        ret, th_art = cv.threshold(img, 5, 255, cv.THRESH_BINARY)
        kernel = np.ones((5, 5), np.uint8)
        th_art = cv.erode(th_art, kernel, iterations=erode)  # Erosion y dilatacion imagen arteria
        th_art = cv.dilate(th_art, kernel, iterations=dilate)
        img_arteria = th_art[190:400, 175:325]
        contours_art, hierarchy_art = cv.findContours(img_arteria, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
        conts_art = filterContoursArtery(contours_art, hierarchy_art)
        conts_art = [cnt + (175, 190) for cnt in conts_art]  # Para compensar el slice anterior
        # Aquí ya hemos obtenido el contorno de la arteria

        # Step 2. Pulmones

        ret, th_lung = cv.threshold(img, 30, 255, cv.THRESH_BINARY)
        cv.fillPoly(th_lung, pts = conts_art, color=(255,255,255)) # Coloreamos de blanco lo que antes era la arteria
        th_lung = cv.erode(th_lung, kernel, iterations=erode) # Erosion y dilatacion imagen pulmon
        th_lung = cv.dilate(th_lung, kernel, iterations=dilate)
        contours_lung, hierarchy_lung = cv.findContours(th_lung, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
        conts_lung = filterContoursLungs(contours_lung, hierarchy_lung)

        # Step 3. Bronquios

        # 3.1. Obtener las coordenadas extremas de los pulmones

        skip = False
        th_bronq = img

        # 3.2. Dibujar los demás contornos

        cv_img = cv.cvtColor(img, cv.COLOR_GRAY2BGR)  # th2 -> ver la umbralizada, img -> ver la original

        cv.drawContours(cv_img, conts_art, -1, (0, 0, 255), 2)
        cv.drawContours(cv_img, conts_lung, -1, (0, 255, 0), 2)


        if (conts_lung.size > 0):
            maxIzq = 9999999
            maxDer = 0
            maxTop = 9999999
            maxBot = 0

            for c in conts_lung: # Ordenar por tamaño y coger solo los dos primeros
                maxIzq = tuple(c[c[:, :, 0].argmin()][0])[0]
                maxDer = tuple(c[c[:, :, 0].argmax()][0])[0]
                maxTop = tuple(c[c[:, :, 1].argmin()][0])[1]
                maxBot = tuple(c[c[:, :, 1].argmax()][0])[1]

             #   if extLeft < maxIzq: maxIzq = extLeft
             #   if extRight > maxDer: maxDer = extRight
             #   if extTop < maxTop: maxTop = extTop
             #   if extBot > maxBot: maxBot = extBot

                img_bronq = img[maxTop:maxBot, maxIzq:maxDer] #mas arriba, mas abajo, mas izq, mas der


                ret, th_bronq = cv.threshold(img_bronq, 15, 255, cv.THRESH_BINARY)
                cv.fillPoly(th_lung, pts=conts_art,
                        color=(255, 255, 255))  # Coloreamos de blanco lo que antes era la arteria
                contours_bronq, hierarchy_bronq = cv.findContours(th_bronq, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
                conts_bronq = filterContoursBronq(contours_bronq, hierarchy_bronq)
                conts_bronq = [cnt + (maxIzq, maxTop) for cnt in conts_bronq]  # Para compensar el slice anterior
                cv.drawContours(cv_img, conts_bronq, -1, (255, 0, 0), 1) # A veces no se ven bien. Normalizar luminosidad?

        cv.imshow("window", cv_img)
    cv.waitKey(0)
    if (len(conts_lung) > 0):
        print(conts_lung[0][0][0,0])
    return conts_lung # conts_lung es un array de arrays, donde cada elemento es un array de un elemento que contiene un array de dos elementos
                      # Para acceder a un punto en concreto habria que hacer conts_lung[0][0][0], o quizá conts_lung[0][0,0]



PATH = []
PATH.append("/home/jaime/Documents/SIB Imagenes seleccionadas/Case 1/")
PATH.append("/home/jaime/Documents/SIB Imagenes seleccionadas/Case 2/")
PATH.append("/home/jaime/Documents/SIB Imagenes seleccionadas/Case 3/")

imageSets = []

imageSet = 0

for i in range(0,3):
    image_files = glob.glob(PATH[i]+"*.dcm")
    image_files.sort()
    images = [(dicom.dcmread(img)).pixel_array for img in image_files]
    imageSets.append(images)

maxGrey = 0
minGrey = 9999999

for i in range(0,len(imageSets[imageSet])): # Obtain the maximum value of grey
    greyValue = mx = np.amax(imageSets[imageSet][i])
    if (greyValue > maxGrey):
        maxGrey = greyValue
    elif (greyValue < minGrey):
        minGrey = greyValue

for i in range(0,len(imageSets[imageSet])):
    imageSets[0][i] = imageSets[imageSet][i] * (np.amax(imageSets[0][i] - minGrey) / (maxGrey - minGrey))

X1 = []
Y1 = []
Z1 = []

X2 = []
Y2 = []
Z2 = []

half_image = 0

for i in range(0,len(imageSets[imageSet])): # Obtain contours and visualize images
    half_image = (imageSets[imageSet][i].shape)[0] / 2
    conts_lung = show_img(imageSets[imageSet][i],5)
    for lung in conts_lung:
        for point in lung:
            if (point[0,0] > half_image):
                X1.append(point[0,0])
                Y1.append(point[0,1])
                Z1.append((len(imageSets[1]) - i))
            else:
                X2.append(point[0, 0])
                Y2.append(point[0, 1])
                Z2.append((len(imageSets[1]) - i))


    # En lungs acabamos teniendo una matriz 3d
    # Tenemos varios pisos, siendo cada piso correspondiente a cada una de las imágenes tomadas
    # En cada uno de los pisos hay UNO O MÁS CONTORNOS, dependiendo de cuántos pulmones se hayan detectado
    # Hay que tener en cuenta esa posibilidad de que haya más de un contorno a la hora de dibujarlos
    #print(filenames[i].dtype)

#fig = plt.figure()
#ax = fig.gca(projection='3d')

#for lvl in lungs:
#    for cnt in lvl:
#        for pt in cnt:
            #ax.plot(pt[0,0],i*0.1,pt[0,1])
 #           ax.plot(3,1,2)

#ax.legend()
#plt.show()

fig = plt.figure()
ax = plt.axes(projection="3d")

X1 = np.array(X1)
Y1 = np.array(Y1)
Z1 = np.array(Z1)

X2 = np.array(X2)
Y2 = np.array(Y2)
Z2 = np.array(Z2)

N1 = 10
N2 = 10
N3 = 10
ma = np.random.choice([0,1], size=(N1,N2,N3), p=[0.99, 0.01])

print(ma.shape, ma)

voxels = np.array([X1, Y1,Z1])
print(voxels.shape, voxels.ndim)

ax.voxels(voxels)
#ax.plot(X1, Y1, Z1, "g,")
#ax.plot(X2, Y2, Z2, "g,")
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_zlabel('z')
ax.auto_scale_xyz([0, 512], [0, 512], [20, 67])
plt.show()

#ds=dicom.dcmread(PATH+'000000.dcm')
#dcm_sample=ds.pixel_array*128
#cv.imshow('sample image dicom',dcm_sample)

