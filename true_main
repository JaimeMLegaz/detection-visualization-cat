import easygui as easygui
import numpy as np
import cv2 as cv
import pydicom as dicom
import glob
from skimage.util import img_as_ubyte
import matplotlib.pyplot as plt
import os
import math
import matplotlib as mpl
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d import axes3d



def getLongContours(contours):
    longCont = []

    for cnt in contours:
        if (len(cnt) > 1000):
            longCont.append(cnt)

    return longCont

it = 0 # Variable global para el conteo de los bordes eliminados de todas las imagenes
def filterContoursLungs(contours, hierarchy):
    global it
    toDelete = []

    for i in range(0,len(hierarchy[0]),1): # Escogemos solo los bordes exteriores (sin contar el más exterior)
        if hierarchy[0,i,3] == -1:
            toDelete.append(i)
         #   print(it,"Eliminado por jerarquía")
            it = it + 1

    cont = np.delete(contours, toDelete, axis=0)
    toDelete = []

    i = 0

    for cnt in cont:
        if len(cnt) < 120:
            toDelete.append(i)
         #   print(it, "Eliminado por longitud")
            it = it + 1
        i = i + 1

    cont = np.delete(cont, toDelete, axis=0)

    return cont


def filterContoursArtery(contours, hierarchy):
    toDelete = []
    for i in range(0,len(hierarchy[0]),1): # Escogemos solo los bordes exteriores (sin contar el más exterior)
        if hierarchy[0,i,3] == -1:
            toDelete.append(i)
        #    print("Eliminado por jerarquía")
    cont = np.delete(contours, toDelete, axis=0)
    toDelete = []

    i=0

    for cnt in cont:
        if (len(cnt) > 65) or (len(cnt) < 20):
            toDelete.append(i)
           # print("Eliminado por longitud")
        else:
            circularity = (4 * math.pi * cv.contourArea(cnt))/(cv.arcLength(cnt, 1) * cv.arcLength(cnt, 1))
          #  print("Circularity =",circularity) # Suele tener como 0.85 de circularity, pero a veces se queda en unos 0.75. Al principio incluso es 0.69~
            if (circularity < 0.60):
                toDelete.append(i)
              #  print("Eliminado por circularidad")
        i = i + 1
    cont = np.delete(cont, toDelete, axis=0)
    return cont

def filterContoursBronq(contours, hierarchy):
    global it
    toDelete = []

    for i in range(0,len(hierarchy[0]),1): # Escogemos solo los bordes exteriores (sin contar el más exterior)
        if hierarchy[0,i,3] == -1:
            toDelete.append(i)
          #  print(it,"Eliminado por jerarquía")
            it = it + 1

    cont = np.delete(contours, toDelete, axis=0)
    return cont



def show_img(img, mode=0, erode=2, dilate=2):
    #img = cv.normalize(img, None, 0, 255, norm_type=cv.NORM_MINMAX, dtype=cv.CV_8U)

    conts_lung = np.empty([1,2])
    conts_bronq = None

    if mode==0: # Modo de solo muestra
        cv.imshow("window",img)
    elif mode==1: # Modo de solo umbralizado
        ret, th2 = cv.threshold(img,80,255,cv.THRESH_BINARY)
        kernel = np.ones((5, 5), np.uint8)
        th2 = cv.erode(th2, kernel, iterations=erode)
        th2 = cv.dilate(th2, kernel, iterations=dilate)
        cv.imshow("window",th2)
    elif mode==2: # Modo de umbralizado + contornos
        ret, th2 = cv.threshold(img, 30, 255, cv.THRESH_BINARY)
        kernel = np.ones((5, 5), np.uint8)
        contours, hierarchy = cv.findContours(th2, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)

        conts_lung = filterContoursLungs(contours, hierarchy)

        cv_img = cv.cvtColor(img,cv.COLOR_GRAY2BGR) # th2 -> ver la umbralizada, img -> ver la original

        cv.drawContours(cv_img, conts_lung, -1, (0, 255, 0), 2)
        cv.imshow("window",cv_img)
    elif mode==3: # Modo de umbralizado + contornos + erosión y dilatación
        ret, th2 = cv.threshold(img, 30, 255, cv.THRESH_BINARY)
        kernel = np.ones((5, 5), np.uint8)
        th2 = cv.erode(th2, kernel, iterations=erode)
        th2 = cv.dilate(th2, kernel, iterations=dilate)
        contours, hierarchy = cv.findContours(th2, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)

        conts_lung = filterContoursLungs(contours, hierarchy)

        cv_img = cv.cvtColor(img, cv.COLOR_GRAY2BGR)  # th2 -> ver la umbralizada, img -> ver la original

        cv.drawContours(cv_img, conts_lung, -1, (0, 255, 0), 2)
        cv.imshow("window", cv_img)
    elif mode==4: # Modo de umbralizado + contornos + erosión y dilatación + detección de arteria aorta

        # Step 1. Arteria

        ret, th_art = cv.threshold(img, 1, 255, cv.THRESH_BINARY)
        kernel = np.ones((5, 5), np.uint8)
        th_art = cv.erode(th_art, kernel, iterations=erode)  # Erosion y dilatacion imagen arteria
        th_art = cv.dilate(th_art, kernel, iterations=dilate-1)
        img_arteria = th_art[190:400, 175:325]
        contours_art, hierarchy_art = cv.findContours(img_arteria, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
        conts_art = filterContoursArtery(contours_art, hierarchy_art)
        conts_art = [cnt + (175, 190) for cnt in conts_art]  # Para compensar el slice anterior
        # Aquí ya hemos obtenido el contorno de la arteria

        # Step 2. Pulmones

        ret, th_lung = cv.threshold(img, 30, 255, cv.THRESH_BINARY)
        cv.fillPoly(th_lung, pts = conts_art, color=(255,255,255)) # Coloreamos de blanco lo que antes era la arteria
        th_lung = cv.erode(th_lung, kernel, iterations=erode) # Erosion y dilatacion imagen pulmon
        th_lung = cv.dilate(th_lung, kernel, iterations=dilate)
        contours_lung, hierarchy_lung = cv.findContours(th_lung, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
        conts_lung = filterContoursLungs(contours_lung, hierarchy_lung)

        # Step 3. Dibujar los contornos


        cv_img = cv.cvtColor(img, cv.COLOR_GRAY2BGR)  # th_x -> ver la umbralizada, img -> ver la original

        cv.drawContours(cv_img, conts_art, -1, (0, 0, 255), 2)
        cv.drawContours(cv_img, conts_lung, -1, (0, 255, 0), 2)
        cv.imshow("window", cv_img)
    elif mode==5: # Modo de umbralizado + contornos + erosión y dilatación + detección de arteria aorta + detección de bronquios

        # Step 1. Arteria

        ret, th_art = cv.threshold(img, 1, 255, cv.THRESH_BINARY)
        kernel = np.ones((5, 5), np.uint8)
        th_art = cv.erode(th_art, kernel, iterations=erode)  # Erosion y dilatacion imagen arteria
        th_art = cv.dilate(th_art, kernel, iterations=dilate-1)
        img_arteria = th_art[220:400, 175:325]
        contours_art, hierarchy_art = cv.findContours(img_arteria, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
        conts_art = filterContoursArtery(contours_art, hierarchy_art)
        conts_art = [cnt + (175, 220) for cnt in conts_art]  # Para compensar el slice anterior
        # Aquí ya hemos obtenido el contorno de la arteria

        # Step 2. Pulmones

        ret, th_lung = cv.threshold(img, 30, 255, cv.THRESH_BINARY)
        cv.fillPoly(th_lung, pts = conts_art, color=(255,255,255)) # Coloreamos de blanco lo que antes era la arteria
        th_lung = cv.erode(th_lung, kernel, iterations=erode) # Erosion y dilatacion imagen pulmon
        th_lung = cv.dilate(th_lung, kernel, iterations=dilate)
        contours_lung, hierarchy_lung = cv.findContours(th_lung, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
        conts_lung = filterContoursLungs(contours_lung, hierarchy_lung)

        # Step 3. Bronquios

        # 3.1. Obtener las coordenadas extremas de los pulmones

        skip = False
        th_bronq = img

        # 3.2. Dibujar los demás contornos

        cv_img = cv.cvtColor(img, cv.COLOR_GRAY2BGR)  # th2 -> ver la umbralizada, img -> ver la original

        cv.drawContours(cv_img, conts_art, -1, (0, 0, 255), 2)
        cv.drawContours(cv_img, conts_lung, -1, (0, 255, 0), 2)


        if (conts_lung.size > 0):
            maxIzq = 9999999
            maxDer = 0
            maxTop = 9999999
            maxBot = 0

            for c in conts_lung: # Ordenar por tamaño y coger solo los dos primeros
                maxIzq = tuple(c[c[:, :, 0].argmin()][0])[0]
                maxDer = tuple(c[c[:, :, 0].argmax()][0])[0]
                maxTop = tuple(c[c[:, :, 1].argmin()][0])[1]
                maxBot = tuple(c[c[:, :, 1].argmax()][0])[1]

             #   if extLeft < maxIzq: maxIzq = extLeft
             #   if extRight > maxDer: maxDer = extRight
             #   if extTop < maxTop: maxTop = extTop
             #   if extBot > maxBot: maxBot = extBot

                img_bronq = img[maxTop:maxBot, maxIzq:maxDer] #mas arriba, mas abajo, mas izq, mas der


                ret, th_bronq = cv.threshold(img_bronq, 15, 255, cv.THRESH_BINARY)
                cv.fillPoly(th_lung, pts=conts_art,
                        color=(255, 255, 255))  # Coloreamos de blanco lo que antes era la arteria
                contours_bronq, hierarchy_bronq = cv.findContours(th_bronq, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
                conts_bronq = filterContoursBronq(contours_bronq, hierarchy_bronq)
                conts_bronq = [cnt + (maxIzq, maxTop) for cnt in conts_bronq]  # Para compensar el slice anterior
                cv.drawContours(cv_img, conts_bronq, -1, (255, 0, 0), 1) # A veces no se ven bien. Normalizar luminosidad?
                cv.imshow("bronq", th_bronq)

        cv.imshow("window", cv_img)
    cv.waitKey(0)
  #  if (len(conts_lung) > 0):
  #      print(conts_lung[0][0][0,0])
    return conts_lung, conts_bronq # conts_lung es un array de arrays, donde cada elemento es un array de un elemento que contiene un array de dos elementos
                      # Para acceder a un punto en concreto habria que hacer conts_lung[0][0][0], o quizá conts_lung[0][0,0]

################## VARIABLES INICIALES #######################

PATH = [] # Lista de los paths a los tres sets de imágenes
PATH.append("/home/jaime/Documents/SIB Imagenes seleccionadas/Case 1/")
PATH.append("/home/jaime/Documents/SIB Imagenes seleccionadas/Case 2/")
PATH.append("/home/jaime/Documents/SIB Imagenes seleccionadas/Case 3/")

imageSets = [] # Lista que contendrá los sets de imágenes
imageSet = int(easygui.buttonbox("Selecciona un set de imágenes:","Select image set",("0","1","2"))) # Índice que determina con qué set trabajaremos
mode = 5
# Modo en el que se trabajará, más info en la función shmow_images

for i in range(0,3): # Introduce las imágenes de los Paths en la lista de imágenes
    image_files = glob.glob(PATH[i]+"*.dcm")
    image_files.sort()
    images = [(dicom.dcmread(img)).pixel_array for img in image_files]
    imageSets.append(images)

################### NORMALIZACIÓN ######################

maxGrey = 0
minGrey = 9999999

for i in range(0,len(imageSets[imageSet])): # Obtain the maximum and minimum value of grey
    greyValue = np.amax(imageSets[imageSet][i])
    if (greyValue > maxGrey):
        maxGrey = greyValue

    greyValue = np.amin(imageSets[imageSet][i])

    if (greyValue < minGrey):
        minGrey = greyValue


factor= 255.0/(maxGrey - minGrey)
for i in range(0,len(imageSets[imageSet])): # Intento de normalización
   # imageSets[imageSet][i] = imageSets[imageSet][i] * (np.amax(imageSets[imageSet][i] - minGrey) / (maxGrey - minGrey))
   imageSets[imageSet][i] = ((imageSets[imageSet][i] - minGrey) * factor).astype(np.uint8)

   print(np.amax(imageSets[imageSet][i]- minGrey),np.amin(imageSets[imageSet][i]))

################# OBTENCION CONTORNOS #####################

# Set 1 (Pulmón der)
X1 = []
Y1 = []
Z1 = []
# Set 2 (Pulmón izq)
X2 = []
Y2 = []
Z2 = []
# Set 3 (Bronquios)

half_image = 0 # Punto medio de la imagen


for i in range(0,len(imageSets[imageSet])): # Obtain contours and visualize images
    half_image = (imageSets[imageSet][i].shape)[0] / 2 # Determinamos el punto medio de la imagen
    conts_lung, conts_bronq = show_img(imageSets[imageSet][i],mode) # Mostramos la imagen con los contornos señalados y obtenemos el contorno (Separar en dos funciones?)
    for lung in conts_lung: # Por cada pulmón
        for point in lung: # Por cada punto en el pulmón
       #     if (point[0,0] > half_image): # Si el punto supera la mitad de la imagen, se lo asignamos al pulmón derecho
                X1.append(point[0,0])
                Y1.append(point[0,1])
                Z1.append((len(imageSets[1]) - i))
       #     else: # Si no, al pulmón izquierdo
       #         X2.append(point[0, 0])
       #         Y2.append(point[0, 1])
       #         Z2.append((len(imageSets[1]) - i))
    if (conts_bronq is not None):
        for bronq in conts_bronq:
            for point in bronq:
            #    if (point[0,0] > half_image): # Si el punto supera la mitad de la imagen, se lo asignamos al pulmón derecho
                    X2.append(point[0,0])
                    Y2.append(point[0,1])
                    Z2.append((len(imageSets[1]) - i))
        #    print("PUNTO",point)
       #     else: # Si no, al pulmón izquierdo
       #         X2.append(point[0, 0])
       #         Y2.append(point[0, 1])
       #         Z2.append((len(imageSets[1]) - i))

voxWidth = (imageSets[imageSet][i].shape)[0]
voxHeight = (imageSets[imageSet][i].shape)[1]
voxels = np.zeros(shape=(voxWidth,voxHeight,len(imageSets[imageSet]))) # Determinamos las dimensiones de la representación 3D

#for i in range(0, len(imageSets[imageSet])):  # Obtain contours and visualize images
#    for lung in conts_lung:
#        for point in lung:
#            voxels[point[0,0],point[0,1],i] = 1 # Establecemos los valores de la matriz de vóxeles

    # En lungs acabamos teniendo una matriz 3d
    # Tenemos varios pisos, siendo cada piso correspondiente a cada una de las imágenes tomadas
    # En cada uno de los pisos hay UNO O MÁS CONTORNOS, dependiendo de cuántos pulmones se hayan detectado
    # Hay que tener en cuenta esa posibilidad de que haya más de un contorno a la hora de dibujarlos
    #print(filenames[i].dtype)

######## VISUALIZATION #########

## PULMONES
fig = plt.figure()
ax = plt.axes(projection="3d")

X1 = np.array(X1)
Y1 = np.array(Y1)
Z1 = np.array(Z1)

X2 = np.array(X2)
Y2 = np.array(Y2)
Z2 = np.array(Z2)

#ax.voxels(voxels) # PARA REPRESENTAR VOXELS
ax.plot(X1, Y1, Z1, "g,") # PARA REPRESENTAR PUNTOS

## BRONQUIOS
ax.plot(X2, Y2, Z2, "b-") # "g,"

ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_zlabel('z')
ax.auto_scale_xyz([0, 512], [0, 512], [20, 67]) # DESCOMENTAR EN CASO DE PUNTOS
plt.show()

####### END VISUALIZATION #######