import easygui as easygui
import numpy as np
import cv2 as cv
import pydicom as dicom
import glob
from skimage.util import img_as_ubyte
import matplotlib.pyplot as plt
import os
import math
import matplotlib as mpl
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d import axes3d


def filterContoursLungs(contours, hierarchy): # Recibe contornos, devuelve los que considera que pertenecen a los pulmones
    toDelete = []

    for i in range(0,len(hierarchy[0]),1): # Escogemos solo los bordes exteriores (sin contar el más exterior)
        if hierarchy[0,i,3] == -1:
            toDelete.append(i)

    cont = np.delete(contours, toDelete, axis=0)
    toDelete = []

    i = 0

    for cnt in cont:
        if len(cnt) < 120: # Eliminamos aquellos que consideremos que son demasiado pequeños para pertenecer a un pulmón
            toDelete.append(i)
        i = i + 1

    cont = np.delete(cont, toDelete, axis=0)

    return cont


def filterContoursArtery(contours, hierarchy): # Recibe contornos, devuelve los que considera que pertenecen a la arteria
    toDelete = []
    for i in range(0,len(hierarchy[0]),1): # Escogemos solo los bordes exteriores (sin contar el más exterior)
        if hierarchy[0,i,3] == -1:
            toDelete.append(i)
    cont = np.delete(contours, toDelete, axis=0)
    toDelete = []

    i=0

    for cnt in cont:
        if (len(cnt) > 65) or (len(cnt) < 20): # Filtramos teniendo en cuenta el tamaño que suele tener la arteria
            toDelete.append(i)
        else: # Filtramos por circularidad
            circularity = (4 * math.pi * cv.contourArea(cnt))/(cv.arcLength(cnt, 1) * cv.arcLength(cnt, 1))
           # La arteria suele tener como 0.85 de circularity, pero a veces se queda en unos 0.75. Al principio incluso es 0.65~
            if (circularity < 0.60):
                toDelete.append(i)
        i = i + 1
    cont = np.delete(cont, toDelete, axis=0)
    return cont

def filterContoursBronq(contours, hierarchy): # Filtramos los contornos, dejando los que creamos que pertenecen a los bronquios
    toDelete = []

    for i in range(0,len(hierarchy[0]),1): # Escogemos solo los bordes exteriores (sin contar el más exterior)
        if hierarchy[0,i,3] == -1:
            toDelete.append(i)

    cont = np.delete(contours, toDelete, axis=0)
    return cont



def show_img(img, mode=0, erode=2, dilate=2):

    conts_lung = np.empty([1,2]) # Inicializamos las matrices que contendrán los pulmones y/o los bronquios
    conts_bronq = None

    if mode==0: # Modo de umbralizado + contornos
        ret, th2 = cv.threshold(img, 30, 255, cv.THRESH_BINARY) # Umbralizado
        contours, hierarchy = cv.findContours(th2, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE) # Seleccion de contornos

        conts_lung = filterContoursLungs(contours, hierarchy) # Filtramos contornos pulmones

        cv_img = cv.cvtColor(img,cv.COLOR_GRAY2BGR) # th2 -> ver la umbralizada, img -> ver la original

        cv.drawContours(cv_img, conts_lung, -1, (0, 255, 0), 2) # Dibujamos los contornos en la imagen original
        cv.imshow("window",cv_img)

    elif mode==1: # Modo de umbralizado + contornos + erosión y dilatación
        ret, th2 = cv.threshold(img, 30, 255, cv.THRESH_BINARY)
        kernel = np.ones((5, 5), np.uint8) # Kernel para dilatación/erosión
        th2 = cv.erode(th2, kernel, iterations=erode) # Erosión
        th2 = cv.dilate(th2, kernel, iterations=dilate) # Dilatación
        contours, hierarchy = cv.findContours(th2, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)

        conts_lung = filterContoursLungs(contours, hierarchy)

        cv_img = cv.cvtColor(img, cv.COLOR_GRAY2BGR)  # th2 -> ver la umbralizada, img -> ver la original

        cv.drawContours(cv_img, conts_lung, -1, (0, 255, 0), 2)
        cv.imshow("window", cv_img)

    elif mode==2: # Modo de umbralizado + contornos + erosión y dilatación + detección de arteria aorta

        # Step 1. Arteria

        ret, th_art = cv.threshold(img, 1, 255, cv.THRESH_BINARY)
        kernel = np.ones((5, 5), np.uint8)
        th_art = cv.erode(th_art, kernel, iterations=erode)  # Erosion y dilatacion imagen arteria
        th_art = cv.dilate(th_art, kernel, iterations=dilate-1)
        img_arteria = th_art[190:400, 175:325] # Cortamos una sección de la imagen, aquella donde aparece siempre la arteria aorta
        contours_art, hierarchy_art = cv.findContours(img_arteria, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
        conts_art = filterContoursArtery(contours_art, hierarchy_art) # Filtramos los contornos para quedarnos siempre con la arteria aorta
        conts_art = [cnt + (175, 190) for cnt in conts_art]  # Para compensar el slice anterior
        # Aquí ya hemos obtenido el contorno de la arteria

        # Step 2. Pulmones

        ret, th_lung = cv.threshold(img, 30, 255, cv.THRESH_BINARY)
        cv.fillPoly(th_lung, pts = conts_art, color=(255,255,255)) # Coloreamos de blanco lo que antes era la arteria
        th_lung = cv.erode(th_lung, kernel, iterations=erode) # Erosion y dilatacion imagen pulmon
        th_lung = cv.dilate(th_lung, kernel, iterations=dilate)
        contours_lung, hierarchy_lung = cv.findContours(th_lung, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
        conts_lung = filterContoursLungs(contours_lung, hierarchy_lung)

        # Step 3. Dibujar los contornos

        cv_img = cv.cvtColor(img, cv.COLOR_GRAY2BGR)  # th_x -> ver la umbralizada, img -> ver la original

        cv.drawContours(cv_img, conts_art, -1, (0, 0, 255), 2) # Contornos de arteria (rojo)
        cv.drawContours(cv_img, conts_lung, -1, (0, 255, 0), 2) # Contornos de pulmones (azul)
        cv.imshow("window", cv_img)

    elif mode==3: # Modo de umbralizado + contornos + erosión y dilatación + detección de arteria aorta + detección de bronquios

        # Step 1. Arteria

        ret, th_art = cv.threshold(img, 1, 255, cv.THRESH_BINARY)
        kernel = np.ones((5, 5), np.uint8)
        th_art = cv.erode(th_art, kernel, iterations=erode)  # Erosion y dilatacion imagen arteria
        th_art = cv.dilate(th_art, kernel, iterations=dilate-1)
        img_arteria = th_art[220:400, 175:325]
        contours_art, hierarchy_art = cv.findContours(img_arteria, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
        conts_art = filterContoursArtery(contours_art, hierarchy_art)
        conts_art = [cnt + (175, 220) for cnt in conts_art]  # Para compensar el slice anterior
        # Aquí ya hemos obtenido el contorno de la arteria

        # Step 2. Pulmones

        ret, th_lung = cv.threshold(img, 30, 255, cv.THRESH_BINARY)
        cv.fillPoly(th_lung, pts = conts_art, color=(255,255,255)) # Coloreamos de blanco lo que antes era la arteria
        th_lung = cv.erode(th_lung, kernel, iterations=erode) # Erosion y dilatacion imagen pulmon
        th_lung = cv.dilate(th_lung, kernel, iterations=dilate)
        contours_lung, hierarchy_lung = cv.findContours(th_lung, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
        conts_lung = filterContoursLungs(contours_lung, hierarchy_lung)

        # Step 3. Bronquios

        # 3.1. Primero dibujamos lo que ya tenemos, porque queremos dibujar los bronquios poco a poco y que queden por encima
        cv_img = cv.cvtColor(img, cv.COLOR_GRAY2BGR)  # th2 -> ver la umbralizada, img -> ver la original

        cv.drawContours(cv_img, conts_art, -1, (0, 0, 255), 2)
        cv.drawContours(cv_img, conts_lung, -1, (0, 255, 0), 2)

        # 3.2. Encontrar los bronquios y dibujarlos
        if (conts_lung.size > 0):
            for c in conts_lung: # Por cada pulmón
                maxIzq = tuple(c[c[:, :, 0].argmin()][0])[0] # Obtenemos las coordenadas más extremas de ese pulmón
                maxDer = tuple(c[c[:, :, 0].argmax()][0])[0] # Solo cogeremos contornos de bronquios que estén dentro
                maxTop = tuple(c[c[:, :, 1].argmin()][0])[1]
                maxBot = tuple(c[c[:, :, 1].argmax()][0])[1]

                img_bronq = img[maxTop:maxBot, maxIzq:maxDer] # Seleccionamos solo la imagen de dentro del pulmón


                ret, th_bronq = cv.threshold(img_bronq, 15, 255, cv.THRESH_BINARY)
                cv.fillPoly(th_lung, pts=conts_art,
                        color=(255, 255, 255))  # Coloreamos de blanco lo que antes era la arteria
                contours_bronq, hierarchy_bronq = cv.findContours(th_bronq, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
                conts_bronq = filterContoursBronq(contours_bronq, hierarchy_bronq)
                conts_bronq = [cnt + (maxIzq, maxTop) for cnt in conts_bronq]  # Para compensar el slice anterior
                cv.drawContours(cv_img, conts_bronq, -1, (255, 0, 0), 1) # Dibujamos el contorno de los bronquios encontrados

        cv.imshow("window", cv_img)
    cv.waitKey(0)
    return conts_lung, conts_bronq

################## VARIABLES INICIALES #######################

PATH = [] # Lista de los paths a los tres sets de imágenes
PATH.append("/home/jaime/Documents/SIB Imagenes seleccionadas/Case 1/")
PATH.append("/home/jaime/Documents/SIB Imagenes seleccionadas/Case 2/")
PATH.append("/home/jaime/Documents/SIB Imagenes seleccionadas/Case 3/")

imageSets = [] # Lista que contendrá los sets de imágenes
imageSet = int(easygui.buttonbox("Selecciona un set de imágenes:","Select image set",("0","1","2"))) # Índice que determina con qué set trabajaremos
mode = int(easygui.buttonbox("Selecciona un modo:\n0: Umbralizado + contornos\n1: 0 + Erosión y dilatación\n2: 1 + Detección arteria\n3: 2 + Detección bronquios","Select mode set",("0","1","2","3"))) # Índice que determina con qué modo trabajaremos

for i in range(0,3): # Introduce las imágenes de los Paths en la lista de imágenes
    image_files = glob.glob(PATH[i]+"*.dcm")
    image_files.sort()
    images = [(dicom.dcmread(img)).pixel_array for img in image_files]
    imageSets.append(images)

################### NORMALIZACIÓN ######################

maxGrey = 0
minGrey = 9999999

for i in range(0,len(imageSets[imageSet])): # Obtain the maximum and minimum value of grey
    greyValue = np.amax(imageSets[imageSet][i])
    if (greyValue > maxGrey):
        maxGrey = greyValue

    greyValue = np.amin(imageSets[imageSet][i])

    if (greyValue < minGrey):
        minGrey = greyValue


factor= 255.0/(maxGrey - minGrey)
for i in range(0,len(imageSets[imageSet])): # Normalización
   imageSets[imageSet][i] = ((imageSets[imageSet][i] - minGrey) * factor).astype(np.uint8)

   print(np.amax(imageSets[imageSet][i]- minGrey),np.amin(imageSets[imageSet][i]))

################# OBTENCION CONTORNOS #####################

# Set 1 (Pulmón der)
X1 = []
Y1 = []
Z1 = []
# Set 2 (Bronquios)
X2 = []
Y2 = []
Z2 = []


half_image = 0 # Punto medio de la imagen


for i in range(0,len(imageSets[imageSet])): # Obtain contours and visualize images
    half_image = (imageSets[imageSet][i].shape)[0] / 2 # Determinamos el punto medio de la imagen
    conts_lung, conts_bronq = show_img(imageSets[imageSet][i],mode) # Mostramos la imagen con los contornos señalados y obtenemos el contorno (Separar en dos funciones?)
    for lung in conts_lung: # Por cada pulmón
        for point in lung: # Por cada punto en el pulmón
       #     if (point[0,0] > half_image): # Si el punto supera la mitad de la imagen, se lo asignamos al pulmón derecho
                X1.append(point[0,0])
                Y1.append(point[0,1])
                Z1.append((len(imageSets[1]) - i))
       #     else: # Si no, al pulmón izquierdo
       #         X2.append(point[0, 0])
       #         Y2.append(point[0, 1])
       #         Z2.append((len(imageSets[1]) - i))
    if (conts_bronq is not None):
        for bronq in conts_bronq:
            for point in bronq:
            #    if (point[0,0] > half_image): # Si el punto supera la mitad de la imagen, se lo asignamos al pulmón derecho
                    X2.append(point[0,0])
                    Y2.append(point[0,1])
                    Z2.append((len(imageSets[1]) - i))
        #    print("PUNTO",point)
       #     else: # Si no, al pulmón izquierdo
       #         X2.append(point[0, 0])
       #         Y2.append(point[0, 1])
       #         Z2.append((len(imageSets[1]) - i))

voxWidth = (imageSets[imageSet][i].shape)[0]
voxHeight = (imageSets[imageSet][i].shape)[1]
voxels = np.zeros(shape=(voxWidth,voxHeight,len(imageSets[imageSet]))) # Determinamos las dimensiones de la representación 3D

#for i in range(0, len(imageSets[imageSet])):  # Obtain contours and visualize images
#    for lung in conts_lung:
#        for point in lung:
#            voxels[point[0,0],point[0,1],i] = 1 # Establecemos los valores de la matriz de vóxeles

    # En lungs acabamos teniendo una matriz 3d
    # Tenemos varios pisos, siendo cada piso correspondiente a cada una de las imágenes tomadas
    # En cada uno de los pisos hay UNO O MÁS CONTORNOS, dependiendo de cuántos pulmones se hayan detectado
    # Hay que tener en cuenta esa posibilidad de que haya más de un contorno a la hora de dibujarlos
    #print(filenames[i].dtype)

######## VISUALIZATION #########

## PULMONES
fig = plt.figure()
ax = plt.axes(projection="3d")

X1 = np.array(X1)
Y1 = np.array(Y1)
Z1 = np.array(Z1)

X2 = np.array(X2)
Y2 = np.array(Y2)
Z2 = np.array(Z2)

#ax.voxels(voxels) # PARA REPRESENTAR VOXELS
ax.plot(X1, Y1, Z1, "g,") # PARA REPRESENTAR PUNTOS

## BRONQUIOS
ax.plot(X2, Y2, Z2, "b-") # "g,"

ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_zlabel('z')
ax.auto_scale_xyz([0, 512], [0, 512], [20, 67]) # DESCOMENTAR EN CASO DE PUNTOS
plt.show()

####### END VISUALIZATION #######